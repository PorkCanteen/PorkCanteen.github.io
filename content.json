{"meta":{"title":"MengQi's blog","subtitle":"","description":"Blog of MQ Chen","author":"MQ Chen","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2022-11-21T15:27:31.947Z","updated":"2022-11-21T15:27:31.947Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"一枚菜的抠脚的前端"},{"title":"archives","date":"2022-10-18T10:32:32.000Z","updated":"2022-10-18T10:32:32.095Z","comments":true,"path":"archives/index.html","permalink":"http://example.com/archives/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2022-10-18T10:33:18.871Z","updated":"2022-10-18T10:33:18.871Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2022-10-18T15:10:38.289Z","updated":"2022-10-18T15:10:38.289Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java学习笔记（一）","slug":"20221125_Java学习笔记（一）","date":"2022-11-25T03:17:24.298Z","updated":"2022-11-28T11:11:10.720Z","comments":true,"path":"2022/11/25/20221125_Java学习笔记（一）/","link":"","permalink":"http://example.com/2022/11/25/20221125_Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"Java入门学习笔记。","text":"前言作为前端开发者，了解一些后端语言知识，在工作日常的前后端交互过程中能够提升一定的效率，也能让自己对整个软件开发的流程及原理有更加深入的了解，同时也能拓宽自己的知识面。本人从基础开始，利用空闲时间学习一些Java的基础知识。 CMDCMD-在windows中，利用命令行的方式操作计算机 CMD常用命令 盘符名称 + 冒号 – 切换到某盘E: dir – 查看当前路径下的内容dir cd 目录 – 进入单极目录cd java cd .. – 回退到上一级目录cd.. cd 目录1\\目录2... – 进入多级目录cd java\\detail cd \\ –回到盘符根目录cd \\ cls –清屏cls exit – 退出命令提示符窗口exit 环境变量通过环境变量记录路径，可以在任意目录下打开指定的软件 配置方法 我的电脑 - 属性 - 高级系统设置 - 环境变量 创建 JAVA_HOME 路径不带 bin D:\\develop\\jdk 配置 path %JAVA_HOME%\\bin Java工具概念 jdk – java开发工具包 JVM虚拟机：Java程序运行的地方 核心类库：Java已经定义好的东西 开发工具 jre – java运行环境 常用开发工具 javac – 编译将Java代码翻译成操作系统能理解的内容的工具 java – 运行运行java的工具 jdb – 调试工具 jhat – 内存分析工具 Java基础概念注释 单行注释// xxx 多行注释/* xxx */ 文档注释/** xxx */ 关键字被Java赋予了特定含义的英文单词 关键字的字母全部小写 常用的代码编辑器，针对关键字有特殊的颜色标记 class关键字：用于创建&#x2F;定义一个类，类是Java最基本的组成单元 字面量数据在程序中的书写格式 整数类型、小数类型33 3.3 字符串类型&quot;HelloWorld&quot; 字符类型&#39;A&#39; &#39;我&#39; 布尔类型true false 空类型null 一些特殊符号 \\t 制表符在打印的时候，把前面的字符串长度补齐到8，或者8的整数倍。最少补一个空格，最多补8个空格12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(&quot;name&quot; + &#x27;\\t&#x27; + &quot;age&quot;); &#125;&#125; 变量程序执行过程中，其值可能发生改变的量（数据） 变量的定义格式数据类型 变量名 &#x3D; 数据值;1int a = 10; 注意 变量只能存一个值 变量名不允许重复定义 一条语句可以定义多个变量 变量在使用之前一定要进行赋值 变量的作用域范围 数据类型 分为基本数据类型和引用数据类似 基本数据类型 整数 a. byte：-128到127 b. short：-32768到32767 c. int（默认）：10位数 d. long：19位数（在数据值的后面需要加一个L作为后缀） 浮点数 a. float：-3.401298e-38到3.402823e+38（在数据值的后面需要加一个F作为后缀） b. double（默认）：-4.9e-324到1.797693e+308 字符 a. char：0-65535 布尔 a. boolean：true false 标识符 由数字、字母、下划线和美元符组成 不能以数字开头 不能是关键字 区分大小写 小驼峰命名：方法、变量 大驼峰命名：类名 键盘录入 导包1import java.util.Scanner; // 导报动作必须出现在类定义的上边 创建对象1Scanner sc = new Scanner(System.in); 接收数据1int i = sc.nextInt(); eg:123456789import java.util.Scanner;public class ScannerDemo &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入整数&quot;); int i = sc.nextInt(); System.out.println(i); &#125;&#125; Java项目结构project(项目) &gt; module(模块) &gt; package(包) &gt; class(类) 运算符算术运算符+ - * / %在代码中，若有小数参与计算，结果可能不精确 数字相加 数字运算时，若数据类型不一样不能运算，需要转为一样的才能运算 double &gt; float &gt; long &gt; int &gt; short &gt; byte 隐式转换(自动类型提升)：取值范围小 -&gt; 大 取值范围小和取值范围大的进行运算，小的先提升为大的，再进行运算byte short char 三种类型的数据在运算时，都会直接先提升为 int 再计算 123456789int a = 10;double b = a;// b -&gt; 10.0int a = 10;double b = 12.3;// c = a + b -&gt; doublebyte a = 10;byte b = 20;// c = a + b -&gt; int 强制转换()：取值范围大 -&gt; 小 若把取值范围大的数值赋值给范围小的变量是不允许的，需要强制转换目标数据类型 变量名 &#x3D; (目标数据类型) 被强制转换的数据; 12double a = 12.3;int b = (int) a; 字符串相加 当 + 操作中出现字符串，则这个 + 就是字符串连接符，而不是算数运算符，它会将前后数据进行拼接产生一个新的字符串 连续进行操作时，从左到右逐个进行 字符相加 byte short char 三种类型的数据在运算的时候，都会直接先提升为 int 再进行计算 当 “字符 + 字符” 和 “字符 + 数字” 时，会把字符通过 ASCII 码表查询到对应的数字再进行计算 自增自减运算符 ++ -- 可以放在变量前或变量后，单独写一行结果一样 区别123456int a = 10;int b = a++;// 先用后加 b:10 a:11int a = 10;int b = ++a;// 先加后用 b:11 a:11 赋值运算符 = += -= *= /= %=123int a = 10;int b = 20;a += b; // 等同于 a = a + b; 底层都隐藏了一个强制类型转换 关系运算符 == != &gt; &lt; &gt;= &lt;= 结果输出 boolean 类型 逻辑运算符 &amp;(且) |(或) ^(异或) !(非) 短路逻辑运算符 &amp;&amp; || 三元运算符 关系表达式 ? 表达式1 : 表达式2 先计算关系表达式的值，若为true则结果为表达式1，否则为表达式2","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"后端","slug":"技术/后端","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"技术/后端/Java","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/%E5%90%8E%E7%AB%AF/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"SVG学习","slug":"20221118_SVG学习","date":"2022-11-18T02:15:00.000Z","updated":"2022-11-20T08:47:59.060Z","comments":true,"path":"2022/11/18/20221118_SVG学习/","link":"","permalink":"http://example.com/2022/11/18/20221118_SVG%E5%AD%A6%E4%B9%A0/","excerpt":"SVG（Scalable Vector Graphics可缩放矢量图）作为一种常见的图片格式，其可以直接通过代码描绘图像并添加交互效果，可以用任何文字处理工具打开SVG图像，且随时可以插入到html中通过浏览器进行查看。本文将对SVG图像的一些基本标签类型及其属性进行介绍。","text":"背景前端开发过程中经常会接触SVG格式的图像，且相较于其他格式图像，SVG为代码形式。前端开发人员若掌握一些基本的SVG语法，可以在绘制一些页面上的图形时具有更高的效率，更少且可读性更高的代码。 概述 SVG意为可缩放矢量图形 SVG使用XML格式定义图像 SVG图像在放大或改变尺寸的情况下其图形质量不会有所损失 SVG是W3C推荐标准 特征 相比JPEG、GIF等图像格式，尺寸更小，可伸缩性更强 可伸缩，不因尺寸影响图形质量 文本可选且可搜索 可以与JavaScript技术一起运行 是纯粹的XML(XML是什么) SVG元素SVG根元素&lt;svg&gt;&lt;/svg&gt; 常用属性 width height SVG矩形&lt;rect/&gt; 常用属性 width height fill 矩形的填充颜色 style css属性 stroke 矩形边框颜色【stroke详情】(stroke详情) rx ry 矩形圆角 示例123&lt;svg width=&quot;500&quot; height=&quot;100&quot;&gt; &lt;rect x=&quot;10&quot; y=&quot;10&quot; width=&quot;150&quot; height=&quot;50&quot; rx=&quot;20&quot; ry=&quot;20&quot; fill=&quot;orange&quot; stroke=&quot;red&quot; /&gt;&lt;/svg&gt; SVG圆形&lt;circle/&gt; 常用属性 cx cy 圆点坐标，若省略则为 (0, 0) r 圆的半径 示例123&lt;svg width=&quot;500&quot; height=&quot;100&quot;&gt; &lt;circle cx=&quot;100&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke=&quot;red&quot; stroke-width=&quot;2&quot; fill=&quot;orange&quot; /&gt;&lt;/svg&gt; SVG椭圆&lt;ellipse/&gt; 常用属性 rx ry 椭圆的水平半径与垂直半径 示例123&lt;svg width=&quot;500&quot; height=&quot;100&quot;&gt; &lt;ellipse cx=&quot;100&quot; cy=&quot;50&quot; rx=&quot;50&quot; ry=&quot;30&quot; stroke=&quot;red&quot; stroke-width=&quot;2&quot; fill=&quot;orange&quot; /&gt;&lt;/svg&gt; SVG直线&lt;line/&gt; 常用属性 x1 y1 直线的开始位置坐标 x2 y2 直线的结束位置坐标 示例123&lt;svg width=&quot;500&quot; height=&quot;100&quot;&gt; &lt;line x1=&quot;0&quot; y1=&quot;0&quot; x2=&quot;200&quot; y2=&quot;200&quot; stroke=&quot;red&quot; stroke-width=&quot;3&quot; /&gt;&lt;/svg&gt; SVG多边形&lt;polygon/&gt; 常用属性 points 组成多边形各个点的坐标 示例1234&lt;svg height=&quot;210&quot; width=&quot;500&quot;&gt; &lt;polygon points=&quot;200,10 250,190 160,210&quot; style=&quot;fill:lime;stroke:purple;stroke-width:1&quot;/&gt;&lt;/svg&gt; SVG多线段&lt;polyline/&gt; 常用属性 points 线段各节点坐标 示例123&lt;svg width=&quot;500&quot; height=&quot;100&quot;&gt; &lt;polyline points=&quot;0,40 40,40 40,80 80,80 80,120 120,120 120,160&quot; fill=&quot;#fff&quot; stroke=&quot;red&quot; /&gt;&lt;/svg&gt; SVG路径&lt;path/&gt; 常用属性 d 轨迹 M &#x3D; moveto L &#x3D; lineto H &#x3D; horizontal lineto V &#x3D; vertical lineto C &#x3D; curveto S &#x3D; smooth curveto Q &#x3D; quadratic Bézier curve T &#x3D; smooth quadratic Bézier curveto A &#x3D; elliptical Arc Z &#x3D; closepath 示例123&lt;svg width=&quot;500&quot; height=&quot;200&quot;&gt; &lt;path d=&quot;M150 0 L75 200 L225 200 Z&quot; /&gt;&lt;/svg&gt; SVG文本&lt;text&gt;&lt;/text&gt; 常用属性 x y 文字位置 transform 旋转、缩放、倾斜、平移 示例123&lt;svg width=&quot;500&quot; height=&quot;100&quot;&gt; &lt;text x=&quot;10&quot; y=&quot;30&quot; fill=&quot;red&quot; transform=&quot;rotate(30 20,40)&quot; style=&quot;font-size: 30px; font-weight: 800;&quot;&gt;study SVG&lt;/text&gt;&lt;/svg&gt; study SVG stoke属性 stroke定义一条线，文本或元素轮廓颜色 stoke-width定义了一条线，文本或元素轮廓厚度 stroke-linecap定义不同类型的开放路径的终结 1234567&lt;svg width=&quot;500&quot; height=&quot;100&quot;&gt; &lt;g fill=&quot;none&quot; stroke=&quot;red&quot; stroke-width=&quot;6&quot;&gt; &lt;path stroke-linecap=&quot;butt&quot; d=&quot;M5 20 l215 0&quot; /&gt; &lt;path stroke-linecap=&quot;round&quot; d=&quot;M5 40 l215 0&quot; /&gt; &lt;path stroke-linecap=&quot;square&quot; d=&quot;M5 60 l215 0&quot; /&gt; &lt;/g&gt;&lt;/svg&gt; stroke-dasharray用于创建虚线 1234567&lt;svg width=&quot;500&quot; height=&quot;100&quot;&gt; &lt;g fill=&quot;none&quot; stroke=&quot;red&quot; stroke-width=&quot;4&quot;&gt; &lt;path stroke-dasharray=&quot;5,5&quot; d=&quot;M5 20 l215 0&quot; /&gt; &lt;path stroke-dasharray=&quot;10,10&quot; d=&quot;M5 40 l215 0&quot; /&gt; &lt;path stroke-dasharray=&quot;20,10,5,5,5,10&quot; d=&quot;M5 60 l215 0&quot; /&gt; &lt;/g&gt;&lt;/svg&gt; 实际运用将以上基本的svg元素运用到实际页面的图形绘制开发中，例如在甘特图中时间轴、进度条等样式布局的开发，详细内容：【使用svg进行甘特图组件开发】 参考资料【MDN】【菜鸟教程】","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"SVG","slug":"技术/前端/SVG","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/SVG/"}],"tags":[{"name":"SVG","slug":"SVG","permalink":"http://example.com/tags/SVG/"},{"name":"XML","slug":"XML","permalink":"http://example.com/tags/XML/"}]},{"title":"JS 使用 new Date() 时间不一致问题","slug":"20221110 JS new Date() 时间不一致问题","date":"2022-11-10T14:30:00.000Z","updated":"2022-11-15T13:05:19.329Z","comments":true,"path":"2022/11/10/20221110 JS new Date() 时间不一致问题/","link":"","permalink":"http://example.com/2022/11/10/20221110%20JS%20new%20Date()%20%E6%97%B6%E9%97%B4%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/","excerpt":"JS 使用 new Date() 创建时间时，根据传入的日期(不包含时分秒)字符串格式不同，创建的出的日期时间有部分不一致现象。本文根据本现象进行梳理，避免实际使用时发生意料外的结果。","text":"背景开发过程中将不同传入时间转换为时间戳，根据时间戳计算进度并渲染成进度图，但是发现部分进度点出现错位的现象。经过检查发现，new Date(date) 中传入的 date 字符串，根据时间格式的不同，可能会导致生成的时间不同(当日0点与当日8点两种情况)。 问题发现经过检查发现，仅当传入字符串格式为 ‘2022-03-04’ 等形式的情况下，得到的时间为8点 123456789new Date(&#x27;2022-03-04&#x27;)Fri Mar 04 2022 08:00:00 GMT+0800 (中国标准时间)new Date(&#x27;2022-12-12&#x27;)Mon Dec 12 2022 08:00:00 GMT+0800 (中国标准时间)new Date(&#x27;2022-3-4&#x27;)Fri Mar 04 2022 00:00:00 GMT+0800 (中国标准时间)new Date(&#x27;2022/03/04&#x27;)Fri Mar 04 2022 00:00:00 GMT+0800 (中国标准时间)... 问题分析及解决方法根据查询资料，了解到原因如下：new Date() 传入的日期字符串，需要能够被 Date.parse() 正确识别。对 ISO 8601 格式的支持中，仅有日期的串 (例如 &quot;1970-01-01&quot;) 会被处理为 UTC 而不是本地时间，与其他格式的串的处理不同。因此，在日常构造日期数据的时候，注意保持日期字符串的一致性，最好使用 2022&#x2F;10&#x2F;01 类型的格式，保证转换后的时间在 00:00:00，或者将时间字符串均精确到秒(2022-02-02 00:00:00)，防止时间不一致造成意料之外的结果。 参考资料","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"技术/前端/JavaScript","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"甘特图组件开发（二） ★","slug":"20221110_甘特图组件开发（二）","date":"2022-11-10T03:00:00.000Z","updated":"2022-11-27T05:46:48.474Z","comments":true,"path":"2022/11/10/20221110_甘特图组件开发（二）/","link":"","permalink":"http://example.com/2022/11/10/20221110_%E7%94%98%E7%89%B9%E5%9B%BE%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"基于甘特图组件开发（一）的内容，本篇将继续完善相关功能并修复之前遗留的问题。包括 ① 自定义时间轴功能 ② 数据交互处理逻辑预留 ③ 样式布局调整 等。","text":"基于甘特图组件开发（一）的内容，本篇将继续完善相关功能并修复之前遗留的问题。包括 ① 自定义时间轴功能 ② 数据交互处理逻辑预留 ③ 样式布局调整 等。 自定义时间轴功能由于常见的甘特图时间轴只支持按照天&#x2F;周&#x2F;月&#x2F;年或者固定的时间单位进行划分，但实际使用场景下有时候会需要按照特定且不规则的时间段对进度数据进行直观划分。因此本组件在原时间轴的基础上添加新的自定义时间轴，可通过数据配置自定义时间段及其标题，具体内容如下。 12345678// 自定义时间轴数据export const customisedList: Array&lt;any&gt; = [ &#123; title: &#x27;版本1.0&#x27;, startDate: &#x27;2022/9/7&#x27;, endDate: &#x27;2022/9/15&#x27; &#125;, &#123; title: &#x27;版本1.1&#x27;, startDate: &#x27;2022/9/15&#x27;, endDate: &#x27;2022/9/24&#x27; &#125;, &#123; title: &#x27;版本2.0&#x27;, startDate: &#x27;2022/9/24&#x27;, endDate: &#x27;2022/9/30&#x27; &#125;, &#123; title: &#x27;版本2.1&#x27;, startDate: &#x27;2022/9/30&#x27;, endDate: &#x27;2022/10/5&#x27; &#125;, &#123; title: &#x27;版本2.2&#x27;, startDate: &#x27;2022/10/5&#x27;, endDate: &#x27;2022/10/13&#x27; &#125;,] 123456789&lt;!-- 自定义时间轴 --&gt;&lt;svg [attr.width]=&quot;dateConfig.svgWidth&quot; [attr.height]=&quot;timeLineHeight&quot;&gt; &lt;g *ngFor=&quot;let item of dateConfig.customisedList; let i = index;&quot;&gt; &lt;rect [attr.x]=&quot;item.start * squareWidth&quot; [attr.y]=&quot;0&quot; [attr.width]=&quot;item.length * squareWidth&quot; [attr.height]=&quot;timeLineHeight&quot; [attr.fill]=&quot;i % 2 === 0 ? &#x27;#ddd&#x27; : &#x27;#eee&#x27;&quot;&gt;&lt;/rect&gt; &lt;text [attr.x]=&quot;(item.start + item.length / 2) * squareWidth - 12&quot; [attr.y]=&quot;timeLineHeight / 2 + 4&quot; style=&quot;font-size: 12px;&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/text&gt; &lt;/g&gt;&lt;/svg&gt; 123456789101112// 配置自定义时间轴private setCustomisedData(): void &#123; customisedList.forEach(item =&gt; &#123; const start = (new Date(item.startDate).getTime() - this.dateConfig.startDate.getTime()) / (24 * 60 * 60 * 1000); const length = (new Date(item.endDate).getTime() - new Date(item.startDate).getTime()) / (24 * 60 * 60 * 1000); this.dateConfig.customisedList.push(&#123; title: item.title, start, length &#125;) &#125;)&#125; 数据交互处理逻辑预留本甘特图涉及数据的增删改查功能。其中具体的新增、编辑、删除均通过弹窗形式操作，本组件进行预留，此处仅提供点击事件。① 添加新增按钮列，放置 + 符号② 为 + 符号绑定单击事件（创建）③ 为表格行添加双击事件（编辑）④ 通过 Angular EventEmitter 将事件触发的方法暴露给调用的父组件 注意：双击事件需要特殊处理，以避免重复触发单击事件 1234567891011121314151617181920212223242526272829// 7. 点击任务自动滚动(单击)private time: number = 200;private timeout: any = null;public scrollToBar(row: any): void &#123; clearTimeout(this.timeout); // 清除第一个单击事件 this.timeout = setTimeout(() =&gt; &#123; // 单击事件 &#125;, this.time)&#125;// 8. 创建/编辑任务(双击)@Output() createTask = new EventEmitter();@Output() createSubTask = new EventEmitter();@Output() editTask = new EventEmitter();public editRow(row: any = null, isCreate: boolean = false): void &#123; clearTimeout(this.timeout); if (isCreate) &#123; // 创建数据处理 if (row) &#123; // 创建二级数据 this.createSubTask.emit(row); &#125; else &#123; // 创建一级数据 this.createTask.emit(row); &#125; &#125; else &#123; // 双击编辑数据处理 this.editTask.emit(row); &#125;&#125; 调用该组件时，定义并传入几个点击事件触发的内容即可。 12345&lt;app-m-gantt (createSubTask)=&quot;createSubTask($event)&quot; (createTask)=&quot;createTask($event)&quot; (editTask)=&quot;editTask($event)&quot;&gt;&lt;/app-m-gantt&gt; 1234567891011121314// 需要自定义的样式（仅传入需要更改的属性）public styleOptions = &#123; containerWidth: &#x27;1600px&#x27;,&#125;// 几个事件触发的函数public createTask(e: any): void &#123; console.log(&#x27;创建一级数据&#x27;);&#125;public createSubTask(e: any): void &#123; console.log(&#x27;创建二级数据&#x27;, e);&#125;public editTask(e: any): void &#123; console.log(&#x27;编辑数据&#x27;, e);&#125; 样式布局调整&amp;样式可配置化 样式布局调整① 时间轴高度从表格高度获取 1234ngAfterViewInit(): void &#123; // 根据表格高度设置进度条行高 this.lineHeight = document.querySelectorAll(&#x27;.row&#x27;)[0].clientHeight;&#125; ② 表格高度调整由于表格 td 天然具有 padding: 1px，故需要将其取消，防止表格行高不一致，造成与右侧甘特图行数据无法对齐的问题。 样式可配置化① 将部分样式（例如进度条颜色、高度、表格高度等）进行整合，统一在ts文件中控制。② 使用 Angular 的 @Input 接收调用本组件的父组件传入的样式值进行部分替换，达到自定义的效果。 1234567891011121314// 自定义样式（父组件传入）@Input() options: any;// 1. 可定义变量public containerWidth: string = &#x27;1500px&#x27;; // 容器宽度// ....ngOnInit(): void &#123; this.preprocessStyles(this.options); // ...&#125;private preprocessStyles(styles: any): void &#123; this.containerWidth = styles.containerWidth || this.containerWidth; // ...&#125; 调用该组件时传入即可 1&lt;app-m-gantt [options]=&quot;styleOptions&quot;&gt;&lt;/app-m-gantt&gt; 可配置样式列表 123456789101112public containerWidth: string = &#x27;1500px&#x27;; // 1.容器宽度 public containerHeight: string = &#x27;auto&#x27;; // 2.容器高度public lineHeight: number = 43; // 3.行高public timeLineHeight: number = 30; // 4.时间轴高度（单层）public squareWidth: number = 40; // 5.格子宽度public barHeight: number = 24; // 6.进度条高度public headHeight: number = 90; // 7.头部整体高度public progressBarColor: string = &#x27;#1e80ff&#x27;; // 8.进度颜色public barColor: string = &#x27;#91beff&#x27;; // 9.进度条颜色public subBarColor: string = &#x27;#e6a23c&#x27;; // 10.子进度颜色public subProgressBarColor: string = &#x27;#f56c6c&#x27;; // 11.子进度条颜色public barFontColor: string = &#x27;#fff&#x27;; // 12.进度条文字颜色 数据传入&amp;&amp;配置使用 @Input 接收父组件传入的数据及配置项 数据格式123456789101112// 任务数据public data: Array&lt;any&gt; = [ &#123; id: &#x27;0&#x27;, name: &#x27;任务1&#x27;, startDate: &#x27;2022/9/10&#x27;, endDate: &#x27;2022/9/20&#x27;, status: &#x27;进行中&#x27;, duration: 10, progress: 0.6 &#125;, &#123; id: &#x27;01&#x27;, name: &#x27;子任务1&#x27;, startDate: &#x27;2022/9/10&#x27;, endDate: &#x27;2022/9/15&#x27;, status: &#x27;进行中&#x27;, duration: 5, progress: 0.9, parentId: &#x27;0&#x27; &#125;, ...]// 自定义时间轴数据public customisedList: Array&lt;any&gt; = [ &#123; title: &#x27;版本1.0&#x27;, startDate: &#x27;2022/9/7&#x27;, endDate: &#x27;2022/9/15&#x27; &#125;, &#123; title: &#x27;版本1.1&#x27;, startDate: &#x27;2022/9/15&#x27;, endDate: &#x27;2022/9/24&#x27; &#125;, ...] 数据预处理传入的数据由于有父子级关系，需提前增加部分属性。说明： open：是否展开下属子项 show：是否需要显示该项 config.openSub：是否在初始化时展开所有子项12345678910111213141516171819202122232425// 有下属子项的父项集合const parents: Array&lt;any&gt; = [];// 展开子项if (this.config.openSub) &#123; data.forEach(row =&gt; &#123; row.show = true; if (!row.parentId) &#123; if (parents.indexOf(row.id) !== -1) &#123; row.open = true &#125; else &#123; row.open = false &#125; &#125; &#125;)&#125; else &#123; // 收起子项 data.forEach(row =&gt; &#123; if (!row.parentId) &#123; row.open = false; row.show = true; &#125; else &#123; row.show = false; &#125; &#125;)&#125; 待续…(完善表格项可配置化、弹窗显示详情内容可配置化、数据配置项等) 【项目GitHub地址】 相关文章【甘特图组件开发（一）】【甘特图组件开发（二）】","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"组件开发","slug":"技术/组件开发","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://example.com/tags/Angular/"},{"name":"组件开发","slug":"组件开发","permalink":"http://example.com/tags/%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91/"}]},{"title":"甘特图组件开发（一） ★","slug":"20221105_甘特图组件开发（一）","date":"2022-11-05T03:00:00.000Z","updated":"2022-11-26T08:57:08.517Z","comments":true,"path":"2022/11/05/20221105_甘特图组件开发（一）/","link":"","permalink":"http://example.com/2022/11/05/20221105_%E7%94%98%E7%89%B9%E5%9B%BE%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"工作中需要使用甘特图组件展示数据，故考虑自主开发一款基于Angular的甘特图组件以满足业务的需求。基本包含以下几项功能：① 根据数据自动渲染进度图；② 支持树形表格数据展示；③ 支持多层时间轴自定义；④ 支持数据增删改查。其余功能将在后续持续拓展完善。","text":"工作中需要使用甘特图组件展示数据，故考虑自主开发一款基于Angular的甘特图组件以满足业务的需求。基本包含以下几项功能：① 根据数据自动渲染进度图；② 支持树形表格数据展示；③ 支持多层时间轴自定义；④ 支持数据增删改查。其余功能将在后续持续拓展完善。 背景 工作中需要在网页上实现甘特图，以展示进度数据。通过网上调研相关项目，找到一款 dhtmlx-gantt 组件，在低程度上满足项目需求，但在部分定制功能（如时间轴自定义、编辑弹窗样式风格等）并不能完全满足项目需求。此外，使用此类开源项目，若遇到功能无法满足需求时，解决起来较为麻烦，基本只有在需求上进行妥协。 个人在工作后暂时没有开发过相对复杂且功能较为完整的组件，开发甘特图组件既可以满足工作需要、方便开发人员，也可以加深自己对前端技术的理解。基于以上原因，开始着手开发一款甘特图组件 m-gantt，第一版首先以完成项目需求为目标，实现项目需要的功能，尽可能将配置项进行提取。后续将继续完善拓展应有功能，实现可配置化。 开发准备 本甘特图开发的基本思路源于这两篇文章：https://juejin.cn/post/7035107631588966430https://juejin.cn/post/7037744201064251423 调研含 dhtmlx-gantt 在内的多款甘特图组件，了解甘特图组件所需要的基本功能以及数据的在展示方法、交互方法等。 其他说明 本甘特图组件目前仅支持 Angular 开发 除 Angular 框架外，本组件无其他依赖包 甘特图基于svg绘画，不依赖其他工具，可塑性强，且相较于使用标签加定位的布局方式，该方法代码量较少且逻辑清晰 样式使用less语法 开发内容概述基本思路 布局布局需要实现如下几项功能① 主要分为左右两个部分，每个部分分上部固定区域和下部垂直滚动区域② 左右部分的下部区域需要同时滚动③ 右部需要横向滚动④（可选）左侧部分支持缩放 表格区域① 基本为常规表格，将表头固定在上部，表体放在下部② 点击行数据可使进度图横向滚动到该项任务所在起始位置 时间轴区域① 分多层，默认分为 年-月层、日层、自定义层② 使用svg语法进行绘制 进度图区域① 使用svg语法绘制② 进度图根据实际数据实时渲染③ 鼠标移动到单个任务进度条上显示数据详情 布局① 主要分为左右两个部分，每个部分分上部固定区域（吸顶）和下部垂直滚动区域② 左右部分的下部区域需要同时滚动（共用滚动条）③ 右部需要横向滚动 12345678&lt;div class=&quot;gantt-table&quot; #table&gt; &lt;div class=&quot;header&quot;&gt;&lt;/div&gt; &lt;div class=&quot;body&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;gantt-chart&quot; #chart&gt; &lt;div class=&quot;header&quot;&gt;&lt;/div&gt; &lt;div class=&quot;body&quot;&gt;&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930.gantt-container &#123; height: 800px; display: flex; // 使用flex布局 overflow: hidden; .gantt-table, .gantt-chart &#123; .header &#123; position: sticky; height: @headHeight; top: 0; &#125; .body &#123; height: 900px; &#125; &#125; // 左侧表格 .gantt-table &#123; position: relative; overflow-x: hidden; overflow-y: scroll; &#125; // 隐藏左侧滚动条 .gantt-table::-webkit-scrollbar &#123; width: 0; &#125; // 右侧进度图 .gantt-chart &#123; overflow-x: scroll; flex: 1; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637@ViewChild(&#x27;table&#x27;) table: any;@ViewChild(&#x27;chart&#x27;) chart: any;public scrollLock = &#123; isTableScroll: false, isChartScroll: false&#125;ngAfterViewInit(): void &#123; // 监听左侧表格 this.table.nativeElement.addEventListener(&#x27;scroll&#x27;, this.scrollChart); // 监听右侧表格 this.chart.nativeElement.addEventListener(&#x27;scroll&#x27;, this.scrollTable);&#125;private scrollChart = (e: any) =&gt; &#123; // 当右侧进度图没有滚动时，使之随表格滚动 if (!this.scrollLock.isChartScroll) &#123; this.scrollLock.isTableScroll = true; this.chart.nativeElement.scroll(&#123; top: e.target?.scrollTop &#125;) &#125; this.scrollLock.isTableScroll = false;&#125;private scrollTable = (e: any) =&gt; &#123; // 当左侧表格没有滚动时，使之随进度图滚动 if (!this.scrollLock.isTableScroll) &#123; this.scrollLock.isChartScroll = true; this.table.nativeElement.scroll(&#123; top: e.target?.scrollTop &#125;) &#125; this.scrollLock.isChartScroll = false;&#125;ngOnDestroy(): void &#123; this.table.nativeElement.removeEventListener(&#x27;scroll&#x27;, this.scrollChart); this.chart.nativeElement.removeEventListener(&#x27;scroll&#x27;, this.scrollTable);&#125; SVG本甘特图使用svg语法绘制，主要用到以下几种常用标签 react 矩形标签 x: 左侧距离 y: 顶部距离 width: 宽度 height: 高度 rx: x轴半径 rx: y轴半径 path 路径标签（eg: M 100 0 V 100） M: move to 传入目标点的坐标 x y H: horizontal lineto 平行线 V: vertical lineto 垂直线 line 线标签 x1 y1: 第一个点的坐标 x2 y2: 第二个点的坐标 text 文本标签 g 组合标签 添加到g上的变化会应用到其子元素 更加详细的SVG图知识可以参考另一篇文章【SVG学习】 时间轴① 计算时间轴的长度② 构造时间数组③ 通过位置绘制时间轴 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 时间轴public dateConfig: any = &#123; startDate: new Date(&#x27;2077-12-31&#x27;), endDate: new Date(&#x27;1999-1-1&#x27;), total: 0, // 总天数 svgWidth: 0, // 整体宽度 svgHeight: 60, // 时间轴高度 dateList: [], // 日轴 monthList: [] // 月轴&#125;// 配置时间轴数据private setGanttData(): void &#123; // 遍历任务数据 获取最大/最小值 this.ganttConfig.data.forEach((task: any) =&gt; &#123; const &#123; startDate, endDate &#125; = task; if (startDate &amp;&amp; new Date(startDate) &lt; this.dateConfig.startDate) &#123; this.dateConfig.startDate = new Date(startDate) &#125; if (endDate &amp;&amp; new Date(endDate) &gt; this.dateConfig.endDate) &#123; this.dateConfig.endDate = new Date(endDate); &#125; &#125;) // 前后加N天保证显示效果 this.dateConfig.endDate = new Date(this.dateConfig.endDate.getTime() + 3 * 24 * 60 * 60 * 1000); this.dateConfig.startDate = new Date(this.dateConfig.startDate.getTime() - 3 * 24 * 60 * 60 * 1000); this.dateConfig.total = (this.dateConfig.endDate.getTime() - this.dateConfig.startDate.getTime()) / (24 * 60 * 60 * 1000); // 计算总宽度 this.dateConfig.svgWidth = this.dateConfig.total * this.squareWidth; // 时间轴 // 日 const week = [&#x27;Mon&#x27;, &#x27;Tue&#x27;, &#x27;Wed&#x27;, &#x27;Thu&#x27;, &#x27;Fri&#x27;, &#x27;Sat&#x27;, &#x27;Sun&#x27;]; for (let i = 0; i &lt; this.dateConfig.total; i++) &#123; this.dateConfig.dateList.push(&#123; text: this.datePipe.transform(new Date(this.dateConfig.startDate.getTime() + i * 24 * 60 * 60 * 1000), &#x27;dd&#x27;), day: week[new Date(this.dateConfig.startDate.getTime() + i * 24 * 60 * 60 * 1000).getDay()], month: this.datePipe.transform(new Date(this.dateConfig.startDate.getTime() + i * 24 * 60 * 60 * 1000), &#x27;yyyy-MM&#x27;), &#125;) &#125; // 月 const monthMap = new Map(); this.dateConfig.dateList.forEach((date: any) =&gt; &#123; const month = date.month; if (monthMap.has(month)) &#123; monthMap.set(month, monthMap.get(month) + 1) &#125; else &#123; monthMap.set(month, 1) &#125; &#125;) let lengthBefore: number = 0; monthMap.forEach((value, key) =&gt; &#123; this.dateConfig.monthList.push(&#123; text: key, left: lengthBefore &#125;) lengthBefore += value; &#125;)&#125; 123456789101112131415161718192021222324&lt;!-- 时间轴 --&gt;&lt;div class=&quot;header&quot; [style.width]=&quot;dateConfig.svgWidth + &#x27;px&#x27;&quot;&gt; &lt;!-- 月数据 --&gt; &lt;svg [attr.width]=&quot;dateConfig.svgWidth&quot; [attr.height]=&quot;timeLineHeight&quot;&gt; &lt;g class=&quot;date&quot; *ngFor=&quot;let month of dateConfig.monthList; let i = index;&quot;&gt; &lt;!-- 文字 --&gt; &lt;text [attr.x]=&quot;month.left * squareWidth + 5&quot; [attr.y]=&quot;timeLineHeight / 2 + 4&quot; style=&quot;font-size: 12px;&quot;&gt;&#123;&#123;month.text&#125;&#125;&lt;/text&gt; &lt;!-- 时间轴边框 --&gt; &lt;path [attr.d]=&quot;&#x27;M &#x27; + month.left * squareWidth + &#x27; 0 V 30&#x27;&quot; stroke=&quot;#d9dde0&quot;&gt;&lt;/path&gt; &lt;line x1=&quot;0&quot; y1=&quot;30&quot; [attr.x2]=&quot;dateConfig.svgWidth&quot; y2=&quot;30&quot; stroke=&quot;#d9dde0&quot; /&gt; &lt;/g&gt; &lt;/svg&gt; &lt;!-- 日数据 --&gt; &lt;svg [attr.width]=&quot;dateConfig.svgWidth&quot; [attr.height]=&quot;timeLineHeight&quot;&gt; &lt;g class=&quot;date&quot; *ngFor=&quot;let date of dateConfig.dateList; let i = index;&quot;&gt; &lt;text [attr.x]=&quot;i * squareWidth + 5&quot; [attr.y]=&quot;timeLineHeight / 2 + 4&quot; style=&quot;font-size: 12px;&quot;&gt;&#123;&#123;date.text&#125;&#125;&lt;/text&gt; &lt;text [attr.x]=&quot;i * squareWidth + 20&quot; [attr.y]=&quot;timeLineHeight / 2 + 4&quot; style=&quot;font-size: 8px;&quot;&gt;&#123;&#123;date.day&#125;&#125;&lt;/text&gt; &lt;path [attr.d]=&quot;&#x27;M &#x27; + i * squareWidth + &#x27; 0 V 30&#x27;&quot; stroke=&quot;#d9dde0&quot;&gt;&lt;/path&gt; &lt;/g&gt; &lt;/svg&gt;&lt;/div&gt; 进度图 背景绘制① 用 react 绘制格子② 用 line 绘制横线③ 用 path 绘制竖线 1234567891011121314// 数据public ganttConfig: any = &#123; columns: columns, data: data, chartData: []&#125;// 数据预处理private preprocessData(data: Array&lt;any&gt;): Array&lt;any&gt; &#123; data.forEach(row =&gt; &#123; const startDay = (new Date(row.startDate).getTime() - this.dateConfig.startDate.getTime()) / (24 * 60 * 60 * 1000); row.startDay = startDay; &#125;) return data;&#125; 12345678910111213&lt;div class=&quot;body&quot;&gt; &lt;svg [attr.width]=&quot;dateConfig.svgWidth&quot; [attr.height]=&quot;ganttConfig.chartData.length * lineHeight&quot;&gt; &lt;rect *ngFor=&quot;let row of ganttConfig.chartData; let i = index;&quot; x=&quot;0&quot; [attr.y]=&quot;lineHeight * i&quot; [attr.width]=&quot;dateConfig.svgWidth&quot; [attr.heigth]=&quot;lineHeight&quot; [attr.fill]=&quot;i % 2 === 0 ? &#x27;#fff&#x27; : &#x27;#f9fafb&#x27;&quot;&gt; &lt;/rect&gt; &lt;path *ngFor=&quot;let date of dateConfig.dateList; let i = index;&quot; [attr.d]=&quot;&#x27;M &#x27; + i * squareWidth + &#x27; 0 V &#x27; + ganttConfig.chartData.length * lineHeight&quot; stoke=&quot;#d9dde0&quot;&gt; &lt;/path&gt; &lt;line *ngFor=&quot;let row of ganttConfig.chartData; let i = index;&quot; x1=&quot;0&quot; [attr.y1]=&quot;lineHeight * i + lineHeight&quot; [attr.x2]=&quot;dateConfig.svgWidth&quot; [attr.y2]=&quot;lineHeight * i + lineHeight&quot; stroke=&quot;#d9dde0&quot; /&gt; &lt;!-- 进度图 --&gt; &lt;/svg&gt;&lt;/div&gt; 进度图 bar 绘制① 用 rect 绘制每项任务的总计划 bar② 用 rect 绘制每项任务的已完成 bar③ 用 text 填充文字 12345678910111213141516&lt;g class=&quot;bar&quot; *ngFor=&quot;let row of ganttConfig.chartData; let i = index;&quot; (mouseenter)=&quot;showDetail(row, true)&quot; (mouseleave)=&quot;showDetail(row)&quot;&gt; &lt;!-- 全部 --&gt; &lt;rect [id]=&quot;&#x27;bar_&#x27; + i&quot; [attr.x]=&quot;row.startDay * squareWidth&quot; [attr.y]=&quot;i * lineHeight + (lineHeight - barHeight) / 2&quot; [attr.width]=&quot;row.duration * squareWidth&quot; [attr.height]=&quot;barHeight&quot; [attr.rx]=&quot;barHeight / 2&quot; [attr.ry]=&quot;barHeight / 2&quot; [attr.fill]=&quot;row.parentId ? subBarColor : barColor&quot;&gt;&lt;/rect&gt; &lt;!-- 进度 --&gt; &lt;rect [attr.x]=&quot;row.startDay * squareWidth&quot; [attr.y]=&quot;i * lineHeight + (lineHeight - barHeight) / 2&quot; [attr.width]=&quot;(row.duration * squareWidth) * row.progress&quot; [attr.height]=&quot;barHeight&quot; [attr.rx]=&quot;barHeight / 2&quot; [attr.ry]=&quot;barHeight / 2&quot; [attr.fill]=&quot;row.parentId ? subProgressBarColor : progressBarColor&quot;&gt; &lt;/rect&gt; &lt;text [attr.x]=&quot;row.startDay * squareWidth + 20&quot; [attr.y]=&quot;(i + 0.5) * lineHeight + 5&quot; [attr.fill]=&quot;barFontColor&quot; style=&quot;font-size: 12px;&quot;&gt;&#123;&#123;row.name&#125;&#125;&lt;/text&gt;&lt;/g&gt; 点击滚动点击任务滚动到任务开始位置 1234567891011121314151617// 点击任务自动滚动public scrollToBar(row: any): void &#123; const targetBar = document.querySelector(`#bar_$&#123;this.ganttConfig.chartData.indexOf(row)&#125;`); if (targetBar &amp;&amp; this.table) &#123; // 目标进度条左侧与client距离 const x = targetBar.getBoundingClientRect().left; // table右侧与client距离 const parentX = this.table.nativeElement.getBoundingClientRect().right; const preScroll = this.chart.nativeElement.scrollLeft || 0; const diff = x - parentX; // 滚动 this.chart.nativeElement.scrollTo(&#123; left: preScroll + diff, behavior: &#x27;smooth&#x27; &#125;) &#125;&#125; 显示详情鼠标移动到任务上显示任务详情① 创建一个modal标签，设置基本样式，在里面放置需要展示的详情② 通过监听鼠标移动事件，将鼠标的位置传递给该元素，实现跟随鼠标移动③ 在鼠标进入 bar 时绑定，在鼠标移出 bar 时解绑 12345678910111213141516171819202122// 弹窗显示详情@ViewChild(&#x27;msgModal&#x27;) msgModal: any;public showModal: boolean = false;public modalData: any = &#123; name: &#x27;任务1&#x27;, startDate: &#x27;2022-10-1&#x27;, status: &#x27;进行中&#x27;, progress: &#x27;&#x27;&#125;public showDetail(row: any, flag = false): void &#123; if (flag) &#123; this.showModal = true; // 绑定数据 // ... document.addEventListener(&#x27;mousemove&#x27;, this.moveModal) &#125; else &#123; this.showModal = false &#125;&#125;private moveModal = (e: any) =&gt; &#123; document.querySelector(&#x27;#msg-modal&#x27;)?.setAttribute(&#x27;style&#x27;, `top: $&#123;e.clientY&#125;px; left: $&#123;e.clientX - 510&#125;px`);&#125; 结构及样式代码略 树形表格树形表格① 表格支持点击 icon 展开与折叠② 进度图的对应项根据表格的折叠与否决定是否显示③ 为了支持父子级关系及控制显示，任务数据需添加以下字段： a: id b: parentId (仅子级数据需要，关联父子关系) c: open (仅父级数据需要，控制是否展开状态，变换icon) d: show (控制是否显示) 1234567891011121314// 表格展开public showSubData(id: string): void &#123; this.ganttConfig.data.forEach((item: any) =&gt; &#123; if (item.id === id) &#123; item.open = !item.open; &#125; if (item.parentId === id) &#123; item.show = !item.show; &#125; &#125;) this.ganttConfig.chartData = this.ganttConfig.data.filter((row: any) =&gt; &#123; return row.show === true &#125;)&#125; 以上，甘特图组件基本功能开发完成，后续工作：① 完善其他实用功能② 修改已有问题③ 将数据、功能、样式封装为可配置项 【项目GitHub地址】 相关文章【甘特图组件开发（一）】【甘特图组件开发（二）】","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"组件开发","slug":"技术/组件开发","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://example.com/tags/Angular/"},{"name":"组件开发","slug":"组件开发","permalink":"http://example.com/tags/%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91/"}]},{"title":"算法学习笔记","slug":"20221019_算法学习笔记","date":"2022-10-19T08:00:00.000Z","updated":"2022-11-20T08:01:56.720Z","comments":true,"path":"2022/10/19/20221019_算法学习笔记/","link":"","permalink":"http://example.com/2022/10/19/20221019_%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"刷了不少算法题，还是感觉算法能力没有比较明显的提升，因此系统性地学习下常见的数据结构与算法知识及解题思路，提升自己的基本代码能力。","text":"递归思想 函数中存在调用函数本身的情况，该现象就称为递归 将大问题逐步分解为小问题来求解，一层层分解，直到问题规模被分解得足够小，可以直接计算结果为止 若将一层层的分解过程画成图，其实就是一棵树 递归在 归 的过程中，符合后进先出的规则，所以需要一个堆栈的数据结构。随着深度增加，栈也增大。若递归缺少终止条件则会爆栈。因此，所有基于递归思想实现的算法，第一步需要思考递归的终止条件 分而治之算法和动态规划算法很大程度是基于递归思想 先 递 后 归，递即将问题逐次拆解成子问题来解决，直到被拆解的子问题无需再拆解成更细的问题（可以求解为止），归即最小的问题解决了，其上一层、上上层…的问题都能得到解决 递归的一般结构 12345678function df() &#123; if(边界条件) &#123; ... return &#125; // 以某种形式调用自身 df()&#125; 三大要素 明确函数功能 寻找递归结束条件 找出函数的等价关系式 基本步骤 定义函数 寻找问题与子问题的关系（递推公式） 将递推公式在函数中实现 判断复杂度 代表题目 爬楼梯；跳台阶；斐波那契；反转二叉树；路径总和 分而治之 把一个复杂的问题分成多个相同或类似的子问题，再把子问题分成更小的子问题，直至最后子问题可以简单直接的求解，则原问题的解即为子问题解的合并。分解出的子问题相互独立且与原问题性质相同 是很多常用算法的基础，如排序算法（快速排序、归并排序）等 最优子结构是依赖特定问题和子问题的分割方式而成立的条件。各子问题具有最优解，就能求出整个问题的最优解；反之，若不能利用子问题的最优解获得整个问题的最优解，则该问题不具有最优子结构 分治思想不一定使用递归结构 分治思想的核心是怎么分 适用场景 问题的规模缩小到一定程度就很容易解决 问题可以分级为若干个规模较小的子问题，即具有最优子结构性质 分解后的子问题的解可以合并为该问题本身的解 分解后的子问题相互独立，不包含公共子问题 基本步骤 分解：将问题分解为若干个独立的子问题 解决：若问题容易解决则直接解决，否则递归分解子问题 合并：将子问题的解合并为原问题的解 重点 是否能发现重复子问题，发现大问题存在的循环子结构 是否能划分步骤，因为单个步骤比整个问题解决起来更加简单 子问题是否容易解决 代表题目 搜索二维矩阵；求众数；合并k个排序列表 ‍待续…","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"算法","slug":"技术/算法","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"博客重启 2022.10","slug":"20221018_博客重启","date":"2022-10-18T10:00:00.000Z","updated":"2022-11-20T12:01:26.081Z","comments":true,"path":"2022/10/18/20221018_博客重启/","link":"","permalink":"http://example.com/2022/10/18/20221018_%E5%8D%9A%E5%AE%A2%E9%87%8D%E5%90%AF/","excerpt":"2022年10月中旬，决定把年初开始就没管的个人博客重建一遍，保留之前部分博文，继续开始总结自己的技术学习笔记，也顺便借此记下自己从转行到适应半年多开发工作的杂乱体会。","text":"2022年10月中旬，决定把年初开始就没管的个人博客重建一遍，保留之前部分博文，继续开始总结自己的技术学习笔记，也顺便借此记下自己从转行到适应半年多开发工作的杂乱体会。 关于个人博客写个人博客的初衷也是想找个地方记录自己学习转行、踏入新工作的一些经历和总结，以及自己在技术提升过程中的一些感想心得、遇到的问题及解决方法等，个人觉得还是很有意义的。从2021年11月初次建站，断断续续更新了小几篇，2022年2月入职工作后主要把精力放在了熟悉工作上，因此暂时停止写博客。后续除了继续更新，也会将工作期间总结的一些纯技术内容补充到博客中。 关于转行我从21年6月开始准备0基础自学转行，到10月辞去上一份工作在家学习，到12月开始投简历求职，于1月拿到offer并在年后入职。 关于前端开发工作选择踏入前端也是基于自己在多方面了解和接触前端开发后，认为自己比较适合这个工作，也有一定的兴趣。实际工作后也确实如此。机械式地完成工作，交付特性显然提升不大。在代码层面提升可读性、可复用性及可扩展性，在业务层面结合实际使用场景，考虑并实际提升用户使用体验，或许能有所收获。","categories":[{"name":"生活","slug":"生活","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/"},{"name":"学习","slug":"生活/学习","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"杭州 2022.10","slug":"20221007_杭州","date":"2022-10-07T04:00:00.000Z","updated":"2022-11-20T08:01:44.713Z","comments":true,"path":"2022/10/07/20221007_杭州/","link":"","permalink":"http://example.com/2022/10/07/20221007_%E6%9D%AD%E5%B7%9E/","excerpt":"","text":"","categories":[{"name":"生活","slug":"生活","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/"},{"name":"旅游","slug":"生活/旅游","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/%E6%97%85%E6%B8%B8/"}],"tags":[]},{"title":"Echarts配置项中的字体无法改变长度单位问题解决","slug":"20220817_Echarts字体单位设置","date":"2022-08-17T01:00:00.000Z","updated":"2022-11-23T14:38:10.769Z","comments":true,"path":"2022/08/17/20220817_Echarts字体单位设置/","link":"","permalink":"http://example.com/2022/08/17/20220817_Echarts%E5%AD%97%E4%BD%93%E5%8D%95%E4%BD%8D%E8%AE%BE%E7%BD%AE/","excerpt":"如何在Echarts的配置项中设置字体的单位。","text":"问题使用Echarts时，通常会在图表对应的配置中设置各个部分的字体，但是配置项中的字体只支持输入数字，其单位默认为px，若需要让字体使用百分比、vw、rem等单位实现自适应效果，则无法直接实现。 例如： 123456789export const options = &#123; xAxis: &#123; axisLabel: &#123; textStyle: &#123; fontSize: 16 // 此处不支持输入 &#x27;2vw&#x27; 等 &#125; &#125; &#125;&#125; 解决方法以vw单位为例，由于直接使用带单位的字符串无效，需要设计一个函数，通过计算，动态得出在当前页面大小时对应的字体大小，代码如下： 1234567function translateFont(size: number): number &#123; // 获得当前页面宽度大小 let clientWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth; if(!clientWidth) return; let fontSize = clientWidth / 2560; // 2560 为字体大小显示为 size 时的页面宽度 return size * fontSize;&#125; 在设置字体的位置调用此函数即可。 注意此方法存在一个问题，页面仅在初始化的时候会调用此方法，因此字体大小在页面初始化后就不会发生变化。若字体需要根据页面大小自适应，则需要监听页面尺寸变化，并更新对应 Echarts 的配置项，这里不再赘述。","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"技术/前端/JavaScript","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"Echarts","slug":"Echarts","permalink":"http://example.com/tags/Echarts/"},{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"}]},{"title":"JS元素拖拽过快失效问题","slug":"20220506-JS元素拖拽过快失效问题","date":"2022-05-06T02:00:00.000Z","updated":"2022-11-20T12:14:26.149Z","comments":true,"path":"2022/05/06/20220506-JS元素拖拽过快失效问题/","link":"","permalink":"http://example.com/2022/05/06/20220506-JS%E5%85%83%E7%B4%A0%E6%8B%96%E6%8B%BD%E8%BF%87%E5%BF%AB%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/","excerpt":"在对页面元素设置拖拽事件，使元素随鼠标进行移动的时候，若鼠标移动速度过快，会导致鼠标跑出元素外导致拖拽提前结束，本文旨在解决上述问题。","text":"问题描述开发过程中需要实现部分元素的自由拖拽效果，但是实现后存在一个问题：当鼠标移动过快，会造成鼠标跑出元素外从而导致拖拽失效。 1234567891011121314// 原代码onMouseDown(e, flag) &#123; // ... // 拖拽 function onMouseMove(e) &#123; moveAt(e.pageX, e.pageY); // 移动元素 &#125; target.addEventListener(&#x27;mousemove&#x27;, onMouseMove); // 放开 function onMouseUp(e) &#123; target.removeEventListener(&#x27;mousemove&#x27;, onMouseMove); &#125; target.addEventListener(&#x27;mouseup&#x27;, onMouseUp);&#125; 问题分析根据上网查询相关资料，结合个人分析，得到问题原因如下：鼠标移动过快，导致 mousemove 事件频繁触发，相应的事件处理函数也频繁调用，引起延迟。延迟过后由于元素的移动速度不及鼠标的移动速度，造成鼠标移动到元素外，从而触发 mouseout 事件，提前结束拖拽。 解决方法将事件处理函数添加到 document 上，而非目标元素上，让 mousemove 事件在有延迟的情况下仍然可以被响应即可。 1234567891011121314// 修改后代码onMouseDown(e, flag) &#123; // ... // 拖拽 function onMouseMove(e) &#123; moveAt(e.pageX, e.pageY); // 移动元素 &#125; document.addEventListener(&#x27;mousemove&#x27;, onMouseMove); // 放开 function onMouseUp(e) &#123; document.removeEventListener(&#x27;mousemove&#x27;, onMouseMove); &#125; target.addEventListener(&#x27;mouseup&#x27;, onMouseUp);&#125; 补充将事件绑定到 document 和 body 上的区别在于：绑定到 document 上，当鼠标移动到菜单栏(边界)上，元素仍然可以拖动，而 body 则无效。 参考文档【参考文档1】【参考文档2】","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"技术/前端/JavaScript","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"西安 2022.05","slug":"20220504_西安","date":"2022-05-04T04:00:00.000Z","updated":"2022-11-20T08:01:36.651Z","comments":true,"path":"2022/05/04/20220504_西安/","link":"","permalink":"http://example.com/2022/05/04/20220504_%E8%A5%BF%E5%AE%89/","excerpt":"","text":"","categories":[{"name":"生活","slug":"生活","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/"},{"name":"旅游","slug":"生活/旅游","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/%E6%97%85%E6%B8%B8/"}],"tags":[]},{"title":"JavaScript 位运算符","slug":"20220124_JavaScript-位运算符","date":"2022-01-24T03:06:33.000Z","updated":"2022-11-20T08:01:31.686Z","comments":true,"path":"2022/01/24/20220124_JavaScript-位运算符/","link":"","permalink":"http://example.com/2022/01/24/20220124_JavaScript-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"位运算就是直接进行二进制运算，属于低级的运算操作，因此相较于一般运算符速度最快。此篇对位运算及其常见使用场景进行总结","text":"位运算就是直接进行二进制运算。位运算属于低级的运算操作，因此相较于一般运算符速度最快。 基本概念&amp; 按位与若两个相应的二进制位都是 1，则该位的结果为 1，否则为 0 | 按位或若两个相应的二进制位有一个是 1，则该位的结果为 1，否则为 0 ^ 按位异或若参加运算的两个二进制位值相同则为 0，否则为 1 ~ 取反用来对一个二进制数按位取反，将 0 变 1,1 变 0 &lt;&lt; 左移用来将一个数的各二进制位全部左移 N 位，右补 0 &gt;&gt; 右移用来将一个数的各二进制位全部右移 N 位，移到右端的低位被舍弃，对于无符号数，高位补 0 实际运用（1）通过 ^ 实现 0 1 切换123toggle ^= 1// 等同于toggle = toggle ? 0 : 1 （2）转换布尔值12console.log(!!7) // trueconsole.log(!!0) // false （3）取整 :star:12345console.log(~~8.3) // 8console.log(8.3 &gt;&gt; 0) // 8console.log(8.3 &lt;&lt; 0) // 8console.log(8.3 | 0) // 8console.log(8.3 &gt;&gt;&gt; 0) // 8 （4）判断符号只能对比整数 1;(a ^ b) &gt;= 0 // true 相同 false 不同 （5）检查数字是否不相等123if(a ^ 12) ...// 等同于if(a !== 12) ... （6）四舍五入123;(a + 0.5) | 0// 等同于Math.round(a)","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"技术/前端/JavaScript","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"continue / break 跳出指定层循环","slug":"20220105_continue-break-跳出指定层循环","date":"2022-01-05T09:29:18.000Z","updated":"2022-11-20T08:01:24.942Z","comments":true,"path":"2022/01/05/20220105_continue-break-跳出指定层循环/","link":"","permalink":"http://example.com/2022/01/05/20220105_continue-break-%E8%B7%B3%E5%87%BA%E6%8C%87%E5%AE%9A%E5%B1%82%E5%BE%AA%E7%8E%AF/","excerpt":"解决问题：两层循环，内层循环中存在 if 判断，当判断成立时需跳出并执行下一轮外层循环。但直接使用 continue 仅跳出内层循环。如何实现跳出指定循环层。","text":"刷算法题的过程中遇到以下问题 问题：两层循环，内层循环中存在 if 判断，当判断成立时需跳出并执行下一轮外层循环。但直接使用 continue 仅跳出内层循环。 123456789while(str = readline()) &#123; ...... for(...) &#123; if(...) &#123; ... continue // 判断成立时需跳出外层 while 循环 &#125; &#125;&#125; 解决方法：使用带 label 的 continuecontinue 后可以带一个 label 标识符号以指定具体跳出的循环 123456789outside: while(str = readline()) &#123; // 通过 label: 的形式为循环添加标识符 ...... for(...) &#123; if(...) &#123; ... continue outside // 指定需跳出的循环层 &#125; &#125;&#125; 注： break 同理 总结自 MDN continuehttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/continuebreakhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/break","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"技术/前端/JavaScript","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"ES6 Class","slug":"20211217_ES6-Class","date":"2021-12-17T03:50:26.000Z","updated":"2022-11-20T08:01:16.983Z","comments":true,"path":"2021/12/17/20211217_ES6-Class/","link":"","permalink":"http://example.com/2021/12/17/20211217_ES6-Class/","excerpt":"ES6 Class 重点知识摘抄","text":"ES6 Class 重点知识摘抄 基本特点 ES6 的 class 可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。ES6 的类，完全可以看作构造函数的另一种写法。 构造函数的 prototype 属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的 prototype 属性上面。在类的实例上面调用方法，其实就是调用原型上的方法。 prototype 对象的 constructor 属性，直接指向“类”的本身，这与 ES5 的行为是一致的。 类的内部所有定义的方法，都是不可枚举的 类必须使用 new 调用，否则会报错。 constructor 方法 constructor 方法是类的默认方法，通过 new 命令生成对象实例时，自动调用该方法。一个类必须有 constructor 方法，如果没有显式定义，一个空的 constructor 方法会被默认添加。 注意点 严格模式类和模块的内部，默认就是严格模式，所以不需要使用 use strict 指定运行模式。 不存在提升类不存在变量提升（hoist），这一点与 ES5 完全不同。 name 属性由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被 Class 继承，包括 name 属性。 Generator 方法 如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。 this 的指向类的方法内部如果含有 this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。 – 摘自 阮一峰 ECMAScript 6 (ES6) 标准入门教程 第三版 (https://www.bookstack.cn/read/es6-3rd/spilt.1.docs-class.md)","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"技术/前端/JavaScript","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://example.com/tags/ES6/"}]},{"title":"JavaScript 继承方式","slug":"20211216_JavaScript-继承方式","date":"2021-12-16T02:26:38.000Z","updated":"2022-11-20T08:01:11.645Z","comments":true,"path":"2021/12/16/20211216_JavaScript-继承方式/","link":"","permalink":"http://example.com/2021/12/16/20211216_JavaScript-%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/","excerpt":"原型链继承；盗用构造函数继承；组合继承；原型式继承；寄生式继承；寄生式组合继承；ES6 继承","text":"0. 前置知识① 构造函数首字母大写。也是函数，区别在于可以通过 new 的方式执行 – this 指向实例对象 1234function Foo() &#123; this.a = 1&#125;var foo = new Foo() ② prototype所有实例的公共祖先。实例对象上可以拿到原型上的属性、方法 12345678Foo.prototype = &#123; aa: 10, constructor: Foo,&#125;console.log(foo.aa) // 10console.log(foo)// a: 1// __proto__: &#123; aa: 10, __proto__: ...&#125; 原型的终点是 Object.prototype 不建议使用 foo.__proto__ 访问，使用 Foo.prototype (或者 ES6 的 Object.getPrototypeOf(foo)) ③ constructor指向构造函数原型对象自身携带的属性，若重写 prototype 需补充该属性Foo.prototype.constructor === Foofoo.constructor === Foo 1. 原型链继承核心理念将父类（被继承）的实例作为子类（继承）的原型 代码12345678910111213141516171819202122232425262728293031// 父类function Parent(job) &#123; this.name = &#x27;C&#x27; this.job = job this.numbers = [1, 2, 3]&#125;Parent.prototype.sayName = function () &#123; console.log(&#x27;My name is &#x27; + this.name)&#125;// 子类function Son() &#123; this.age = 12&#125;// 实现继承Son.prototype = new Parent()Son.prototype.sayScore = function () &#123; return this.score&#125;const s1 = new Son()const s2 = new Son()s1.numbers.push(4)s1.sayName() // My name is Cconsole.log(s1.name) // Cconsole.log(s1.job) // undefined 无法传参console.log(s1.numbers) // [1, 2, 3, 4]console.log(s2.numbers) // [1, 2, 3, 4] 引用值共享// 访问顺序如下 (连接原型链) ★// s1 -&gt; Son.prototype(new Parent) -&gt; Parent.prototype 存在问题 原型中包含的引用值会在所有实例中共享。使得实例属性变成原型属性 子类型在实例化时不能给父类型的构造函数传参 2. 盗用构造函数继承核心理念在子类构造函数中调用父类构造函数，并通过 call apply 方法以新创建的对象为上下文执行构造函数 代码1234567891011121314151617181920function Parent(name) &#123; this.numbers = [1, 2, 3] this.name = name&#125;Parent.prototype.sayName = function () &#123; console.log(this.name)&#125;function Son() &#123; // 实现继承 Parent.call(this, &#x27;B&#x27;) // 可以多个&#125;const s1 = new Son()const s2 = new Son()s1.numbers.push(4)console.log(s1.numbers) // [1, 2, 3, 4]console.log(s2.numbers) // [1, 2, 3] 引用值不共享console.log(s1.name) // &#x27;B&#x27; 传参s1.sayName() // 报错 Uncaught TypeError: s1.sayName is not a function 存在问题 必须在构造函数中定义方法，因此函数不可用 子类无法访问父类原型上定义的方法，因此所有类型只能使用构造函数模式 3. 组合继承 (伪经典继承)核心理念通过盗用构造函数继承属性；通过原型链继承方法。结合了原型链继承和盗用构造函数继承二者的优点 代码1234567891011121314151617function Parent(name) &#123; this.name = name&#125;Parent.prototype.sayName = function () &#123; console.log(this.name)&#125;function Son(name) &#123; // 继承属性 Parent.call(this, name)&#125;// 继承方法Son.prototype = new Parent()const s1 = new Son(&#x27;A&#x27;)console.log(s1.name) // As1.sayName() // A 存在问题 两次调用父类构造函数，消耗内存较多 子类构造函数会代替原型上的父类构造函数 4. 原型式继承核心理念复制一个对象并通过函数包装 代码12345678function objext(o) &#123; function F() &#123;&#125; F.prototype = o return new F()&#125;// ECMAScript5 新增 Object.create() 方法，将原型式继承规范化const another = Object.create(person) 存在问题 属性中的引用值会在相关对象间共享 适用于不需要单独创建构造函数，但仍然需要在对象间共享信息的场合 5. 寄生式继承核心理念给原型式继承外添加一层函数用以接收参数 代码12345678910111213function object(o) &#123; function F() &#123;&#125; F.prototype = o return new F()&#125;function createNew(origin) &#123; const clone = object(origin) clone.sayHi = function () &#123; console.log(&#x27;Hi&#x27;) &#125; return clone&#125; 存在问题 无法复用 适用于主要关注对象，不在乎类型和构造函数的场景 6. 寄生式组合继承 (经典继承) :star:核心理念通过组合修复以上方法的问题 代码123456789101112131415161718192021222324function Parent(name) &#123; this.name = name&#125;Parent.prototype.sayName = function () &#123; console.log(this.name)&#125;function Son(name) &#123; // 继承属性 Parent.call(this, name)&#125;// 继承方法if (!Object.create) &#123; Object.create = function (proto) &#123; function F() &#123;&#125; F.prototype = proto return new F() &#125;&#125;Son.prototype = Object.create(Super.prototype)const s1 = new Son(&#x27;A&#x27;)console.log(s1.name) // As1.sayName() // A 7. ES6 继承核心理念运用 ES6 Class ，简化代码 代码123456789101112131415161718class Parent &#123; constructor(name = &#x27;a&#x27;) &#123; this.name = name &#125; say() &#123; console.log(`my name is $&#123;this.name&#125;`) &#125;&#125;class Son extends Parent &#123; constructor(name = &#x27;b&#x27;) &#123; // 继承父类属性 super(name) &#125; eat() &#123; // 继承父类方法 super.say() &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"技术/前端/JavaScript","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"Vue 组件上传 npm 流程","slug":"20211215_Vue-组件上传-npm-流程","date":"2021-12-15T04:24:57.000Z","updated":"2022-11-20T08:01:06.498Z","comments":true,"path":"2021/12/15/20211215_Vue-组件上传-npm-流程/","link":"","permalink":"http://example.com/2021/12/15/20211215_Vue-%E7%BB%84%E4%BB%B6%E4%B8%8A%E4%BC%A0-npm-%E6%B5%81%E7%A8%8B/","excerpt":"将 Vue 项目中通用组件打包上传 npm 流程","text":"在做 Vue 项目过程中，封装了一个通用组件，想将其上传至 npm 方便后续直接使用。（该组件存在于项目中 src&#x2F;components&#x2F;module 目录下，名称为 CitySelect ） 上传流程第一步src 中新建文件夹，命名为组件名，其中新建文件 index.js 用于 vue 插件模式。 vue 插件模式vue 的插件模式中必须提供一个公开方法 install 。该方法会在使用 Vue.use(Plugin) 时被调用。 index.js 123456789import CitySelect from &#x27;../components/module/CitySelect.vue&#x27;// Vue 插件模式需暴露 install 方法CitySelect.install = function (Vue) &#123; Vue.component(CitySelect.name, CitySelect)&#125;export default CitySelect 第二步在根目录 package.json 中配置打包信息 1234&quot;script&quot;: &#123; ... &quot;city-select&quot;: &quot;vue-cli-service build --target lib ./src/city-select/index.js --dest city-select --name city-select&quot;&#125; target lib - 关键字 指定打包的目录name - 打包后的文件名称dest - 打包后的文件夹名称 第三步项目根目录上打开终端，执行 npm run city-select 开始打包根目录生成组件文件夹 第四步在项目根目录新建文件夹 packages 并将文件 city-select.umd.min.js 复制到该文件夹将 city-select.css 文件复制到 packages 文件夹下 style 子文件夹内 第五步在 packages 文件夹中打开终端，执行命令 npm init -y 初始化 package.json 文件 第六步修改 package.json 中对应内容 123456789101112&#123; &quot;name&quot;: &quot;m-city-select&quot;, 组件名 &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, 对应打包后的组件js文件名(此处统一修改为了 index.js) &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [&quot;vue&quot;, &quot;js&quot;, &quot;css&quot;, &quot;form&quot;], 关键字 &quot;author&quot;: &quot;xxx&quot;, 作者 &quot;license&quot;: &quot;ISC&quot;&#125; 第七步切换为 npm 官方源 nrm use npm (nrm ls 查看当前源)执行 npm login 登录账户 第八步执行 npm publish 发布包到 npm 发布完成 使用流程执行 npm i m-city-select在需要引入组件的位置进行引入 12345678import CitySelect from &#x27;m-city-select&#x27;import &#x27;m-city-select/style/city-select.css&#x27;export default &#123; name: &#x27;xxx&#x27;, components: &#123; CitySelect, &#125;,&#125; 1&lt;city-select&gt;&lt;/city-select&gt; 更新方法修改版本号、说明，执行 npm publish","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"npm","slug":"技术/前端/npm","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/npm/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"npm","slug":"npm","permalink":"http://example.com/tags/npm/"}]},{"title":"达瓦更扎 2021.12","slug":"20211213_达瓦更扎","date":"2021-12-13T02:25:38.000Z","updated":"2022-11-20T08:01:00.966Z","comments":true,"path":"2021/12/13/20211213_达瓦更扎/","link":"","permalink":"http://example.com/2021/12/13/20211213_%E8%BE%BE%E7%93%A6%E6%9B%B4%E6%89%8E/","excerpt":"","text":"","categories":[{"name":"生活","slug":"生活","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/"},{"name":"旅游","slug":"生活/旅游","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/%E6%97%85%E6%B8%B8/"}],"tags":[]},{"title":"MVVM 理解","slug":"20211208_MVVM-理解","date":"2021-12-08T08:49:39.000Z","updated":"2022-11-20T08:00:55.996Z","comments":true,"path":"2021/12/08/20211208_MVVM-理解/","link":"","permalink":"http://example.com/2021/12/08/20211208_MVVM-%E7%90%86%E8%A7%A3/","excerpt":"MVVM ：Model-View-ViewModel","text":"MVVM ：Model-View-ViewModel 是一种软件架构模式 View视图 - 用户在屏幕上看到的结构、布局、外观 Model模型 - 代表内容的数据访问层 ViewModel视图模型 - 暴露公共属性和命令的视图的抽象 Vue 中的 MVVMView 和 Model 没有直接联系，而是通过 ViewModel 进行交互核心：ViewModel，是一个 Vue 实例从 View 向 Model 方向，通过 DOM Listeners 检测页面的元素变化并更改 Model 中数据；从 Model 向 View 方向，当更新 Model 中数据时，通过 Data Bindings 更新页面元素 （部分内容摘自 wiki 百科）","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"技术/前端/Vue","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"Vue 城市联动下拉选择组件实现","slug":"20211130_Vue-城市联动下拉选择组件实现","date":"2021-11-30T09:36:55.000Z","updated":"2022-11-20T08:00:47.898Z","comments":true,"path":"2021/11/30/20211130_Vue-城市联动下拉选择组件实现/","link":"","permalink":"http://example.com/2021/11/30/20211130_Vue-%E5%9F%8E%E5%B8%82%E8%81%94%E5%8A%A8%E4%B8%8B%E6%8B%89%E9%80%89%E6%8B%A9%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0/","excerpt":"在做项目的过程中遇到需要选择城市的表单，需要使得 省市区 三级联动选择。element-ui 中有相关组件，但该组件将三者统一在同一个 select 下拉选择框，使得数据双向绑定时还需要切分数据。故考虑根据实际开发情况封装一个通用的联动下拉选择组件。","text":"在做项目的过程中遇到需要选择城市的表单，需要使得 省市区 三级联动选择。element-ui 中有相关组件，但该组件将三者统一在同一个 select 下拉选择框，使得数据双向绑定时还需要切分数据。故考虑根据实际开发情况封装一个通用的联动下拉选择组件。 组件代码template 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div class=&quot;city-select&quot;&gt; &lt;div&gt; &lt;!-- 选择省份时：更新市、区数据 --&gt; &lt;select v-model=&quot;province&quot; @change=&quot; updateCity() updateDistrict() pushData() &quot; &gt; &lt;option v-for=&quot;(item, index) in list&quot; :key=&quot;index&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/option&gt; &lt;/select&gt; &lt;select v-model=&quot;city&quot; @change=&quot; updateDistrict() pushData() &quot; &gt; &lt;option v-for=&quot;(item, index) in cityList&quot; :key=&quot;index&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/option&gt; &lt;/select&gt; &lt;select v-model=&quot;district&quot; @change=&quot;pushData&quot;&gt; &lt;option v-for=&quot;(item, index) in DistrictList&quot; :key=&quot;index&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; script 123456789101112131415161718192021222324252627282930313233343536373839404142// 引入省市区数据import list from &#x27;../../../public/data/cities-code.json&#x27;export default &#123; name: &#x27;city-select&#x27;, data() &#123; return &#123; list, // 总数据 province: &#x27;北京&#x27;, // 省 cityList: [], // 市数据, city: &#x27;&#x27;, // 市 DistrictList: [], // 区数据 district: &#x27;&#x27;, // 区 &#125; &#125;, methods: &#123; // 根据省的选择更新市数据 updateCity() &#123; this.list.forEach((item) =&gt; &#123; if (item.name === this.province) &#123; this.cityList = item.children &#125; &#125;) this.city = this.cityList[0].name &#125;, // 根据市的选择更新区数据 updateDistrict() &#123; this.cityList.forEach((item) =&gt; &#123; if (item.name === this.city) &#123; this.DistrictList = item.children &#125; &#125;) this.district = this.DistrictList ? this.DistrictList[0].name : &#x27;&#x27; &#125;, // 数据变化时将数据传递给调用本组件的父组件 (在省市区数据变化时均触发数据推送) pushData() &#123; this.$emit(&#x27;updateData&#x27;, this.province, this.city, this.district) &#125;, &#125;, mounted() &#123; // this.updateCity() &#125;,&#125; style (sass) 1234567891011// 默认样式.city-select &#123; select &#123; height: 40px; width: 175px; line-height: 40px; border: 1px solid #e5e5e5; padding: 0 10px; margin-right: 15px; &#125;&#125; 使用方法 引入组件 1import CitySelect from &#x27;@/components/module/CitySelect.vue&#x27; 使用组件 1&lt;city-select @updateData=&quot;updateData&quot;&gt;&lt;/city-select&gt; 获取数据并使用 12345updateData(province, city, district) &#123; this.receiverProvince = province this.receiverCity = city this.receiverDistrict = district&#125;, 效果展示 组件特点 省市区联动，会自动根据上一级选择筛选对应的子级可选项 选择省份会自动填充默认 市、区 使用注意事项 导入城市数据格式要求：[&#123;name: &#39;某某省&#39;, children: [...]&#125;, &#123;...&#125;, ...] 本组件设置有默认样式，如需更改，在父组件中通过 &#x2F;deep&#x2F; 样式穿透进行设置。例如.city-select /deep/ select &#123;......&#125; 遇到的问题及解决方案 引用该组件往往需要进行双向数据绑定，但绑定的数据存在于子组件，需要使用数据的是父组件。故考虑使用 $emit 进行数据传输，在数据变化时将省市区三个数据同时传递给父组件，并在父组件接收并使用数据 省市区数据来源：http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/ 其他 :snowflake:该组件已修改并上传 npm 方便使用地址：https://www.npmjs.com/package/m-city-select","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"技术/前端/Vue","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]}],"categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"后端","slug":"技术/后端","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"技术/后端/Java","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/%E5%90%8E%E7%AB%AF/Java/"},{"name":"前端","slug":"技术/前端","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"SVG","slug":"技术/前端/SVG","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/SVG/"},{"name":"JavaScript","slug":"技术/前端/JavaScript","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/JavaScript/"},{"name":"组件开发","slug":"技术/组件开发","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"name":"算法","slug":"技术/算法","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"},{"name":"生活","slug":"生活","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/"},{"name":"学习","slug":"生活/学习","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/%E5%AD%A6%E4%B9%A0/"},{"name":"旅游","slug":"生活/旅游","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/%E6%97%85%E6%B8%B8/"},{"name":"npm","slug":"技术/前端/npm","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/npm/"},{"name":"Vue","slug":"技术/前端/Vue","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/Vue/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"SVG","slug":"SVG","permalink":"http://example.com/tags/SVG/"},{"name":"XML","slug":"XML","permalink":"http://example.com/tags/XML/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"Angular","slug":"Angular","permalink":"http://example.com/tags/Angular/"},{"name":"组件开发","slug":"组件开发","permalink":"http://example.com/tags/%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"Echarts","slug":"Echarts","permalink":"http://example.com/tags/Echarts/"},{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"},{"name":"ES6","slug":"ES6","permalink":"http://example.com/tags/ES6/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"npm","slug":"npm","permalink":"http://example.com/tags/npm/"}]}